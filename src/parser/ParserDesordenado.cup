// Define el paquete del parser
package parser;

import java_cup.runtime.*;
import parser.ParseNode;

// Sección de funciones auxiliares para construir nodos
parser code {:
    ParseNode Arbol = new ParseNode("Arbol");
:};

// Define las terminales (tokens) que provienen de JFlex
terminal PLUS, TIMES, LPAREN, RPAREN, MINUS, DIVIDE, MOD, NOT_OP, 
         BIT_AND, COMMA, DOT, LT_OP, GT_OP, ASSIGN, QUESTION, COLON, 
         SEMICOLON, LBRACKET, RBRACKET, LCURLY, RCURLY, 
         BIT_OR, BIT_NOT, BIT_XOR, AND_OP, OR_OP, INC_OP, DEC_OP,
         PLUS_ASSIGN, MINUS_ASSIGN, TIMES_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, 
         LSHIFT, RSHIFT, LSHIFT_ASSIGN, RSHIFT_ASSIGN, BIT_AND_ASSIGN, BIT_OR_ASSIGN, 
         BIT_XOR_ASSIGN, NE_OP, EQ_OP, LE_OP, GE_OP, PTR_OP, NUMBER, IDENTIFIER,
         STRING_LITERAL, CHAR_LITERAL, HEX_LITERAL, OCTAL_LITERAL, BINARY_LITERAL, 
         DOUBLE_LITERAL, AUTO, BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, 
         DOUBLE, ELSE, ENUM, EXTERN, FLOAT, FOR, GOTO, IF, INT, LONG, REGISTER, 
         RETURN, SHORT, SIGNED, SIZEOF, STATIC, STRUCT, SWITCH, TYPEDEF, UNION, 
         UNSIGNED, VOID, VOLATILE, WHILE, READ, WRITE;

// Define los no terminales (estructuras sintácticas)
nonterminal ParseNode program, declaration, typeSpec, declarator, expr, struct, stmt, stmt_list, main_function;

// Declaraciones de precedencia
precedence left OR_OP;          // "||"
precedence left AND_OP;         // "&&"
precedence left EQ_OP, NE_OP;   // "==" y "!="
precedence left LT_OP, GT_OP, LE_OP, GE_OP; // "<", ">", "<=", ">="
precedence left PLUS, MINUS;    // "+" y "-"
precedence left TIMES, DIVIDE;  // "*", "/", "%"
precedence left ELSE;           // "!"

// Producción de inicio
start with program;

program ::= program declaration:d
            {:
              if (RESULT == null) {
                RESULT = Arbol; // Asegura que RESULT apunte al nodo raíz "Arbol"
              }
              ((ParseNode) Arbol).addChild(d); // Agrega la declaración como hijo de Arbol
            :}
          | program stmt:s
            {:
              if (RESULT == null) {
                RESULT = Arbol;
              }
              ((ParseNode) Arbol).addChild(s);
            :}
          | declaration:d
            {:
              RESULT = Arbol; // Asegura que el resultado esté en el árbol global
              ((ParseNode) Arbol).addChild(d); // Primera declaración agregada al árbol
            :}
          | stmt:s
            {:
              RESULT = Arbol;
              ((ParseNode) Arbol).addChild(s);
            :};


stmt_list ::= stmt_list stmt
            | stmt;

// Producción para una declaración de variable con asignación
declaration ::= typeSpec:t declarator:d ASSIGN expr:e SEMICOLON
                {:
                    ParseNode node = new ParseNode("declaration");
                    node.addChild(t);    // Añade el tipo como ParseNode
                    node.addChild(d);    // Añade el identificador como ParseNode
                    node.addChild(e);    // Añade la expresión de asignación como ParseNode
                    RESULT = node;
                :}
                | typeSpec:t declarator:d SEMICOLON
                {:
                    ParseNode node = new ParseNode("declaration");
                    node.addChild(t);    // Añade el tipo como ParseNode
                    node.addChild(d);    // Añade el identificador como ParseNode
                    RESULT = node;
                :}
                | struct:s SEMICOLON
                  {:
                    ParseNode node = new ParseNode("declaration");
                    node.addChild(s);    // Añade la estructura como ParseNode
                    RESULT = node;
                  :};

// Producción para definir una estructura - solo funciona con una declaración tipo: struct Point { int x;};
struct ::= STRUCT IDENTIFIER:id LCURLY declaration:d RCURLY 
            {:
                ParseNode node = new ParseNode("struct " + id.toString());
                node.addChild(new ParseNode(id.toString())); // Añade el identificador de la estructura
                node.addChild(d); // Añade las declaraciones de la estructura
                RESULT = node;
            :}
            | ;

// Definiciones de tipos de datos
typeSpec ::= CONST typeSpec:t {: RESULT = new ParseNode("const"); RESULT.addChild(t); :}
           |INT {: RESULT = new ParseNode("int"); :}
           | CHAR {: RESULT = new ParseNode("char"); :}
           | FLOAT {: RESULT = new ParseNode("float"); :}
           | DOUBLE {: RESULT = new ParseNode("double"); :}
           | VOID {: RESULT = new ParseNode("void"); :};

// Definición del declarador (identificador de variable)
declarator ::= IDENTIFIER:id
                {:
                    RESULT = new ParseNode(id.toString());
                :};

// Producción para expresiones aritméticas
expr ::= expr:e1 PLUS expr:e2   {: 
            ParseNode node = new ParseNode("+");
            node.addChild(e1);  // Convierte e1 a ParseNode
            node.addChild(e2);  // Convierte e2 a ParseNode
            RESULT = node;
        :}
      | expr:e1 MINUS expr:e2   {: 
            ParseNode node = new ParseNode("-");
            node.addChild(e1);  // Convierte e1 a ParseNode
            node.addChild(e2);  // Convierte e2 a ParseNode
            RESULT = node;
        :}
      | expr:e1 TIMES expr:e2   {: 
            ParseNode node = new ParseNode("*");
            node.addChild(e1);  // Convierte e1 a ParseNode
            node.addChild(e2);  // Convierte e2 a ParseNode
            RESULT = node;
        :}
      | expr:e1 DIVIDE expr:e2  {: 
            ParseNode node = new ParseNode("/");
            node.addChild(e1);  // Convierte e1 a ParseNode
            node.addChild(e2);  // Convierte e2 a ParseNode
            RESULT = node;
        :}
      | LPAREN expr:e RPAREN    {: RESULT = e; :}
      | NUMBER:n                {: RESULT = new ParseNode(n.toString()); :}
      | DOUBLE_LITERAL:d         {: RESULT = new ParseNode(d.toString()); :}
      | STRING_LITERAL:s         {: RESULT = new ParseNode(s.toString()); :}
      | CHAR_LITERAL:c           {: RESULT = new ParseNode(c.toString()); :}
      | IDENTIFIER:id            {: RESULT = new ParseNode(id.toString()); :}
      |;


// se declara read y write
stmt ::= READ LPAREN RPAREN SEMICOLON
        {:
            ParseNode node = new ParseNode("read");
            RESULT = node;
        :}
      | READ LPAREN IDENTIFIER:id RPAREN SEMICOLON
        {:
            ParseNode node = new ParseNode("read");
            node.addChild(new ParseNode(id.toString())); // Agrega el identificador como hijo
            RESULT = node;
        :}
      | WRITE LPAREN expr:e RPAREN SEMICOLON
        {:
            ParseNode node = new ParseNode("write");
            node.addChild(e); // Agrega la expresión como hijo
            RESULT = node;
        :};