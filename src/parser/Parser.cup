// Define el paquete del parser
package parser;

import java_cup.runtime.*;
import parser.ParseNode;

// Sección de funciones auxiliares para construir nodos
parser code {:
    ParseNode Arbol = new ParseNode("Arbol");

    //algunos errores
    public void syntax_error(Symbol s){
      System.out.println("Error sintáctico en la línea " + s.left + " columna " + s.right);
    }

    public void fatal_error(Symbol s) {
        System.out.println("Error fatal en la línea " + s.left + " columna " + s.right);
    }
:};

// Define las terminales (tokens) que provienen de JFlex
terminal PLUS, TIMES, LPAREN, RPAREN, MINUS, DIVIDE, MOD, NOT_OP, 
         BIT_AND, COMMA, DOT, LT_OP, GT_OP, ASSIGN, QUESTION, COLON, 
         SEMICOLON, LBRACKET, RBRACKET, LCURLY, RCURLY, 
         BIT_OR, BIT_NOT, BIT_XOR, AND_OP, OR_OP, INC_OP, DEC_OP,
         PLUS_ASSIGN, MINUS_ASSIGN, TIMES_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, 
         LSHIFT, RSHIFT, LSHIFT_ASSIGN, RSHIFT_ASSIGN, BIT_AND_ASSIGN, BIT_OR_ASSIGN, 
         BIT_XOR_ASSIGN, NE_OP, EQ_OP, LE_OP, GE_OP, PTR_OP, NUMBER, IDENTIFIER,
         STRING_LITERAL, CHAR_LITERAL, HEX_LITERAL, OCTAL_LITERAL, BINARY_LITERAL, 
         DOUBLE_LITERAL, AUTO, BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, 
         DOUBLE, ELSE, ENUM, EXTERN, FLOAT, FOR, GOTO, IF, INT, LONG, REGISTER, 
         RETURN, SHORT, SIGNED, SIZEOF, STATIC, STRUCT, SWITCH, TYPEDEF, UNION, 
         UNSIGNED, VOID, VOLATILE, WHILE, LBRACE, RBRACE, PRINTF;

// Define los no terminales (estructuras sintácticas)
nonterminal ParseNode program, declaration, typeSpec, declarator, stmt, stmt_list, expr;

// Define terminales
terminal ID;

// Sección de declaraciones de precedencia
precedence left OR_OP;          // "||"
precedence left AND_OP;         // "&&"
precedence left EQ_OP, NE_OP;   // "==" y "!="
precedence left LT_OP, GT_OP, LE_OP, GE_OP; // "<", ">", "<=", ">="
precedence left PLUS, MINUS;    // "+" y "-"
precedence left TIMES, DIVIDE;  // "*", "/", "%"
precedence left ELSE;           // "!"


// Producción de inicio
start with program;

// Producción para manejar expresiones con punto y coma al final
program ::= program declaration:d
                    {: 
                      if (RESULT == null) {
                        RESULT = Arbol; // Asegura que RESULT apunte al nodo raíz "Arbol"
                      }
                      ((ParseNode) Arbol).addChild(d); // Agrega la declaración como hijo de Arbol
                    :}
                    | declaration:d
                    {:
                      RESULT = Arbol; // Asegura que el resultado esté en el árbol global
                      ((ParseNode) Arbol).addChild(d); // Primera declaración agregada al árbol
                    :};

// Producción para una declaración de variable con asignación
declaration ::= typeSpec:t declarator:d ASSIGN expr:e SEMICOLON
                {:
                    ParseNode node = new ParseNode("declaration");
                    node.addChild(t);    // Añade el tipo como ParseNode
                    node.addChild(d);    // Añade el identificador como ParseNode
                    node.addChild(e);    // Añade la expresión de asignación como ParseNode
                    RESULT = node;
                :};

stmt_list ::= stmt_list stmt 
            | stmt;

stmt ::= IF LPAREN expr RPAREN stmt ELSE stmt
       | IF LPAREN expr RPAREN stmt
       | ID LPAREN RPAREN LBRACE stmt_list RBRACE
       | ID LPAREN RPAREN LBRACE RBRACE
       | INT ID SEMICOLON
       | FLOAT ID SEMICOLON
       | PRINTF LPAREN expr RPAREN SEMICOLON
       | expr SEMICOLON;

// Definiciones de tipos de datos
typeSpec ::= INT {: RESULT = new ParseNode("int"); :}
           | CHAR {: RESULT = new ParseNode("char"); :}
           | FLOAT {: RESULT = new ParseNode("float"); :}
           | DOUBLE {: RESULT = new ParseNode("double"); :}
           | VOID {: RESULT = new ParseNode("void"); :};

// Definición del declarador (identificador de variable)
declarator ::= IDENTIFIER:id
                {:
                    RESULT = new ParseNode(id.toString());
                :};

// Producción para expresiones aritméticas
expr ::= expr:e1 PLUS expr:e2   {: 
            ParseNode node = new ParseNode("+");
            node.addChild(e1);  // Convierte e1 a ParseNode
            node.addChild(e2);  // Convierte e2 a ParseNode
            RESULT = node;
        :}
      | expr:e1 MINUS expr:e2   {: 
            ParseNode node = new ParseNode("-");
            node.addChild(e1);  // Convierte e1 a ParseNode
            node.addChild(e2);  // Convierte e2 a ParseNode
            RESULT = node;
        :}
      | expr:e1 TIMES expr:e2   {: 
            ParseNode node = new ParseNode("*");
            node.addChild(e1);  // Convierte e1 a ParseNode
            node.addChild(e2);  // Convierte e2 a ParseNode
            RESULT = node;
        :}
      | expr:e1 DIVIDE expr:e2  {: 
            ParseNode node = new ParseNode("/");
            node.addChild(e1);  // Convierte e1 a ParseNode
            node.addChild(e2);  // Convierte e2 a ParseNode
            RESULT = node;
        :}
      | LPAREN expr:e RPAREN    {: RESULT = e; :}
      | NUMBER:n                {: RESULT = new ParseNode(n.toString()); :}
      | DOUBLE_LITERAL:d        {: RESULT = new ParseNode(d.toString()); :}
      | IF LPAREN expr:cond RPAREN expr:thenStmt ELSE expr:elseStmt
        {: 
            ParseNode node = new ParseNode("if");
            node.addChild(cond);      
            node.addChild(thenStmt);  
            node.addChild(elseStmt);  
            RESULT = node;
        :}
      | IF LPAREN expr:cond RPAREN expr:thenStmt
        {: 
            ParseNode node = new ParseNode("if");
            node.addChild(cond);      
            node.addChild(thenStmt);  
            RESULT = node;
        :}
      ;