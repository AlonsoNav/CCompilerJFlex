// Define el paquete del parser
package parser;

import java_cup.runtime.*;
import parser.ParseNode;

// Secci√≥n de funciones auxiliares para construir nodos
parser code {:
    ParseNode Arbol = new ParseNode("Arbol");
:};

//-----Simbolos no terminales------
// Define las terminales (tokens) que provienen de JFlex

// Operadores aritmeticos
terminal PLUS, MINUS, DIVIDE, MOD, PLUS_ASSIGN, MINUS_ASSIGN, 
         DIV_ASSIGN, MOD_ASSIGN, TIMES_ASSIGN, TIMES, INC_OP, DEC_OP;

// Operadores relacionales
terminal EQ_OP, GE_OP, GT_OP, QUESTION, LE_OP, LT_OP, NE_OP, COLON;

// Operadores logicos
terminal OR_OP, AND_OP, NOT_OP;

// Operadores binarios
terminal LSHIFT_ASSIGN, RSHIFT_ASSIGN, BIT_AND_ASSIGN, BIT_XOR_ASSIGN, 
         BIT_OR_ASSIGN, BIT_AND, BIT_XOR, BIT_OR, RSHIFT, LSHIFT, BIT_NOT;

// Otros Operadores
terminal PTR_OP, ASSIGN, DOT, COMMA, SEMICOLON, LPAREN, RPAREN, LCURLY,
         RCURLY, LBRACKET, RBRACKET;    

// literales
terminal NUMBER, HEX_LITERAL, OCTAL_LITERAL, BINARY_LITERAL, DOUBLE_LITERAL,
         STRING_LITERAL, CHAR_LITERAL;

// Estructuras de control
terminal IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, DO;


// Final de expresiones o Estructuras
terminal BREAK, RETURN;

// Intruccion de flujo
terminal CONTINUE, GOTO;

// tipos
terminal VOID, INT, CHAR, FLOAT, DOUBLE, SHORT, LONG, SIGNED, UNSIGNED,
         CONST, ENUM;

// Palabras clave
terminal AUTO, REGISTER, STATIC, EXTERN, RESTRICT, VOLATILE;

// Palabras reservadas
terminal UNION, STRUCT, SIZEOF, TYPEDEF, READ, WRITE, MAIN, IDENTIFIER;



//-----Simbolos no terminales------
non terminal INICIO, SENTENCIA, DECLARACION, DECLARACION_FOR, IFs, IF_ELSE,
    WHILEs, DO_WHILE, FORs, SENTENCIA_BOOLEANA, SENTENCIA_FOR, T_DATO, OP_RELACIONALES, 
    OP_LOGICOS, OP_ARITMETICOS, OP_BIT, READ_WRITE;


//-----Precedencias------
precedence left OR_OP;                // ||
precedence left AND_OP;               // &&
precedence nonassoc EQ_OP, NE_OP;     // ==, !=
precedence nonassoc LT_OP, LE_OP, GT_OP, GE_OP; // <, <=, >, >=
precedence left BIT_OR;               // |
precedence left BIT_XOR;              // ^
precedence left BIT_AND;              // &
precedence left LSHIFT, RSHIFT;       // <<, >>
precedence left PLUS, MINUS;          // +, -
precedence left TIMES, DIVIDE, MOD;   // *, /, %
precedence right NOT_OP, BIT_NOT, INC_OP, DEC_OP; // !, ~, ++, --
precedence left DOT, PTR_OP;          // ., ->


start with INICIO;

INICIO ::= 
    INT MAIN LPAREN RPAREN LCURLY SENTENCIA RCURLY |
    MAIN LPAREN RPAREN LCURLY SENTENCIA RCURLY
;
SENTENCIA ::= 
    SENTENCIA DECLARACION |
    DECLARACION |
    SENTENCIA IF | 
    IF |
    SENTENCIA IF_ELSE |
    IF_ELSE |
    SENTENCIA WHILE |
    WHILE |
    SENTENCIA DO_WHILE
    DO_WHILE |
    SENTENCIA FOR |
    FOR |
    SENTENCIA READ_WRITE |
    READ_WRITE
;
DECLARACION ::= 
    T_DATO IDENTIFIER SEMICOLON | 
    T_DATO IDENTIFIER PLUS_ASSIGN NUMBER SEMICOLON |
    T_DATO IDENTIFIER MINUS_ASSIGN NUMBER SEMICOLON |
    T_DATO IDENTIFIER TIMES_ASSIGN NUMBER SEMICOLON |
    T_DATO IDENTIFIER DIV_ASSIGN NUMBER SEMICOLON |
    T_DATO IDENTIFIER MOD_ASSIGN NUMBER SEMICOLON |
    T_DATO IDENTIFIER ASSIGN NUMBER SEMICOLON |
    T_DATO IDENTIFIER ASSIGN STRING_LITERAL SEMICOLON |
    T_DATO IDENTIFIER ASSIGN CHAR_LITERAL SEMICOLON |
    T_DATO IDENTIFIER INC_OP SEMICOLON |
    T_DATO IDENTIFIER DEC_OP SEMICOLON |
    AUTO DECLARACION |
    CONST DECLARACION |
    STATIC DECLARACION |
    VOLATILE DECLARACION
;
IFs ::= IF LPAREN SENTENCIA_BOOLEANA RPAREN LCURLY SENTENCIA RCURLY
;

SENTENCIA_BOOLEANA ::= 
    IDENTIFIER OP_RELACIONALES NUMBER |
    IDENTIFIER OP_RELACIONALES IDENTIFIER |
    IDENTIFIER OP_RELACIONALES STRING_LITERAL |
    IDENTIFIER OP_RELACIONALES CHAR_LITERAL |
    IDENTIFIER OP_RELACIONALES DOUBLE_LITERAL |
    IDENTIFIER OP_RELACIONALES BINARY_LITERAL |
    IDENTIFIER OP_RELACIONALES HEX_LITERAL |
    IDENTIFIER OP_RELACIONALES OCTAL_LITERAL
;

IF_ELSE ::= IF LPAREN SENTENCIA_BOOLEANA RPAREN LCURLY SENTENCIA RCURLY ELSE LCURLY SENTENCIA RCURLY
;
WHILEs ::= WHILE LPAREN SENTENCIA_BOOLEANA RPAREN LCURLY SENTENCIA RCURLY
;
DO_WHILE ::= DO LCURLY SENTENCIA RCURLY WHILE LPAREN SENTENCIA_BOOLEANA RPAREN SEMICOLON
;
FORs ::= FOR LPAREN SENTENCIA_FOR RPAREN LCURLY SENTENCIA RCURLY
;
SENTENCIA_FOR ::=
    T_DATO IDENTIFIER ASSIGN NUMBER SEMICOLON SENTENCIA_BOOLEANA SEMICOLON DECLARACION_FOR |
    IDENTIFIER ASSIGN NUMBER SEMICOLON SENTENCIA_BOOLEANA SEMICOLON DECLARACION_FOR
;
DECLARACION_FOR ::= 
    IDENTIFIER PLUS_ASSIGN NUMBER |
    IDENTIFIER MINUS_ASSIGN NUMBER |
    IDENTIFIER TIMES_ASSIGN NUMBER |
    IDENTIFIER DIV_ASSIGN NUMBER |
    IDENTIFIER MOD_ASSIGN NUMBER |
    IDENTIFIER INC_OP | 
    IDENTIFIER DEC_OP |
    INC_OP IDENTIFIER |
    DEC_OP IDENTIFIER
;

READ_WRITE ::= 
    READ LPAREN IDENTIFIER RPAREN SEMICOLON |
    WRITE LPAREN IDENTIFIER RPAREN SEMICOLON
;

T_DATO ::= INT | CHAR | DOUBLE | FLOAT |;
OP_RELACIONALES ::= EQ_OP | NE_OP | LT_OP | GT_OP | LE_OP | GE_OP | COLON |;
OP_LOGICOS ::= OR_OP | AND_OP | NOT_OP |;
OP_ARITMETICOS ::= PLUS | MINUS | TIMES | DIVIDE | MOD | INC_OP | DEC_OP | PLUS_ASSIGN | MINUS_ASSIGN | TIMES_ASSIGN | DIV_ASSIGN | MOD_ASSIGN |;
OP_BIT ::= BIT_AND | BIT_OR | BIT_XOR | BIT_NOT | LSHIFT | RSHIFT | LSHIFT_ASSIGN | RSHIFT_ASSIGN | BIT_AND_ASSIGN | BIT_OR_ASSIGN | BIT_XOR_ASSIGN |;