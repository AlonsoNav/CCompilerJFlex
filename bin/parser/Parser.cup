package parser;

import java_cup.runtime.*;
import java.util.HashMap;
import java.util.List;
import java.util.Stack;
import java.util.ArrayList;
import semantic.SymbolTable;
import semantic.Translator.PilaS;
import semantic.Translator.RS;
import semantic.LabelGenerator;

parser code {:
    // Tabla de símbolos
    //private HashMap<String, Object> symbolTable = new HashMap<>();
    private SymbolTable symbolTable = new SymbolTable();
    private LabelGenerator labelGenerator = new LabelGenerator();
    public String code = "";

    // Para saber si la variable es global o no
    private boolean isGlobal = true;
    private String currentFunction = null; 

    // Pila semántica
    private PilaS pilaSemantica = new PilaS();
    private PilaS pilaSemanticaVar = new PilaS();
    
    // Pila semántica para contextos (if, while, etc.)
    private Stack<Integer> contextStack = new Stack<>();
    private int nextLabel = 1;

    public SymbolTable getSymbolTable() {
        return symbolTable;
    }

    void syntaxError(Symbol sym, String message) {
        System.err.println("Error de sintaxis en línea " + sym.left + ": " + message);
    }

    @Override
    public void report_error(String message, Object info) {
    }

    @Override
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        throw new RuntimeException("Fatal error in parser.");
    }

    @Override
    public void syntax_error(Symbol s) {
    }

    public void unrecovered_syntax_error(Symbol s) throws Exception {
        String symbol = (s.value != null) ? s.value.toString() : "símbolo desconocido";
        String peek = (stack.elementAt(stack.size() - 3) != null) ? (((Symbol) stack.elementAt(stack.size() - 3)).value).toString() : "símbolo desconocido";
        Object left = (stack.elementAt(stack.size() - 3) != null) ? (((Symbol) stack.elementAt(stack.size() - 3)).left) : "símbolo desconocido";
        String message = "Error de sintaxis no recuperable en línea " + (s.left) + ": Símbolo '" + symbol + "' no esperado." + peek + " " + left;
        System.err.println(message);
        throw new Exception("Error de análisis sintáctico: " + message);
    }
:};

// Define las terminales (tokens) que provienen de JFlex
terminal PLUS, TIMES, LPAREN, RPAREN, MINUS, DIVIDE, MOD, NOT_OP, 
         BIT_AND, COMMA, DOT, LT_OP, GT_OP, ASSIGN, QUESTION, COLON, 
         SEMICOLON, LBRACKET, RBRACKET, LCURLY, RCURLY, 
         BIT_OR, BIT_NOT, BIT_XOR, AND_OP, OR_OP, INC_OP, DEC_OP,
         PLUS_ASSIGN, MINUS_ASSIGN, TIMES_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, 
         LSHIFT, RSHIFT, LSHIFT_ASSIGN, RSHIFT_ASSIGN, BIT_AND_ASSIGN, BIT_OR_ASSIGN, 
         BIT_XOR_ASSIGN, NE_OP, EQ_OP, LE_OP, GE_OP, PTR_OP, NUMBER, IDENTIFIER,
         STRING_LITERAL, CHAR_LITERAL, HEX_LITERAL, OCTAL_LITERAL, BINARY_LITERAL, 
         DOUBLE_LITERAL, AUTO, BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, 
         DOUBLE, ELSE, ENUM, EXTERN, FLOAT, FOR, GOTO, IF, INT, LONG, REGISTER, 
         RETURN, SHORT, SIGNED, SIZEOF, STATIC, STRUCT, SWITCH, TYPEDEF, UNION, 
         UNSIGNED, VOID, VOLATILE, WHILE, READ, WRITE;

non terminal INICIO, SENTENCIA, DECLARACION, EXPRESION_FOR, ESTRUCTURA_IF, ESTRUCTURA_ELSE,
    ESTRUCTURA_WHILE, ESTRUCTURA_FOR, EXPRESIONES, SENTENCIA_FOR, T_DATO, OP_RELACIONALES, 
    OP_LOGICOS, OP_ARITMETICOS, OP_BIT, READ_WRITE, LITERALES, ID_LIST, FUNCION, PARAMETROS, 
    CONTROL_STATEMENT, GLOBAL_DECLARACIONES, FUNCIONES, EXPRESION_ASIGNACION, INCREMENTO_DECREMENTO, 
    EXPRESION_ARITMETICA, EXPRESIONES_RELACIONAL, SENTENCIAS, EXPRESIONES_LOGICAS, ARGUMENTOS,
    DO_WHILE, SWITCHs, CASES, DEFAULT_STMT, CASE_STMT, DECLARACION_LIST, EXPRESIONES_NUMERICAS,
    LISTA_EXPRESIONES, ERRORES_IF, LISTA_DEFAULT, CUERPO_FUNCION, ERRORES_FUNCION, INICIO_WHILE, 
    FIN_CONDICION_WHILE, CUERPO_WHILE, INICIO_SENTENCIA_WHILE, CIERRE_SENTENCIA_WHILE, CUERPO_IF,
    INICIO_IF, FIN_CONDICION_IF, INICIO_SENTENCIA_IF, CIERRE_SENTENCIA_IF;


precedence left OR_OP;
precedence left AND_OP;
precedence nonassoc EQ_OP, NE_OP;
precedence nonassoc LT_OP, GT_OP, LE_OP, GE_OP;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence right INC_OP, DEC_OP;
precedence right NOT_OP;
precedence right ASSIGN, PLUS_ASSIGN, MINUS_ASSIGN, TIMES_ASSIGN, DIV_ASSIGN;
precedence right LPAREN, RPAREN;

start with INICIO;

INICIO ::= GLOBAL_DECLARACIONES FUNCIONES |
           FUNCIONES |
           GLOBAL_DECLARACIONES {: syntaxError(((Symbol) stack.peek()), "El programa debe tener al menos una función."); :} |
           {: syntaxError(((Symbol) stack.peek()), "El programa debe tener al menos una función."); :} |
           error {: syntaxError(((Symbol) stack.peek()), "Error en la estructura del programa."); :} |
           GLOBAL_DECLARACIONES error {: syntaxError(((Symbol) stack.peek()), "Error en la estructura del programa."); :} 
;

GLOBAL_DECLARACIONES ::= DECLARACION |
                        GLOBAL_DECLARACIONES DECLARACION
;

FUNCIONES ::= FUNCION |
              FUNCIONES FUNCION
;

FUNCION ::= 
    T_DATO:typeFunction IDENTIFIER:id LPAREN PARAMETROS:params {:
        isGlobal = false;
        currentFunction = (String) id;
        symbolTable.addFunction((String) id, (String) typeFunction, "global", ((Symbol) stack.peek()).left, "function");

        if (params instanceof List<?>) {
            String c= "parameter";
            try {
                for (List<String> param : (List<List<String>>) params) {
                    if (param.size() == 2) {
                        String type = param.get(0);
                        String identifier = param.get(1);

                        RS nuevoSimbolo = new RS((String) identifier, (String) type);
                        pilaSemanticaVar.push(nuevoSimbolo);

                        RS simbolo = pilaSemanticaVar.pop();
                        symbolTable.addVar(simbolo.getValue(), simbolo.getType(), c, ((Symbol) stack.peek()).left, "variable", currentFunction);
                    } else {
                        // Manejar el error de la lista de parámetros
                        System.err.println("Error: param no es una lista de dos elementos.");
                    }
                }
            } catch (ClassCastException e) {
                // Manejar el error de casting
                System.err.println("Error: params no es una lista de listas de cadenas.");
            }
        }
    :} RPAREN CUERPO_FUNCION |
    T_DATO:typeFunction IDENTIFIER:id LPAREN  {: 
        isGlobal = false;
        currentFunction = (String) id;
        symbolTable.addFunction((String) id, (String) typeFunction, "global", ((Symbol) stack.peek()).left, "function");

    :} RPAREN CUERPO_FUNCION |
    VOID IDENTIFIER:id LPAREN  {: 
        isGlobal = false;
        currentFunction = (String) id;
        symbolTable.addFunction((String) id, "void", "global", ((Symbol) stack.peek()).left, "function");
    :} RPAREN CUERPO_FUNCION |
    VOID IDENTIFIER:id LPAREN PARAMETROS:params  {:
        System.out.println("Parametros: " + params); 
        isGlobal = false;
        currentFunction = (String) id;
        symbolTable.addFunction((String) id, "void", "global", ((Symbol) stack.peek()).left, "function");
        if (params instanceof List<?>) {
            String context= "parameter";
            try {
                for (List<String> param : (List<List<String>>) params) {
                    if (param.size() == 2) {
                        String type = param.get(0);
                        String identifier = param.get(1);

                        RS nuevoSimbolo = new RS((String) identifier, (String) type);
                        pilaSemanticaVar.push(nuevoSimbolo);

                        RS simbolo = pilaSemanticaVar.pop();
                        symbolTable.addVar(simbolo.getValue(), simbolo.getType(), context, ((Symbol) stack.peek()).left, "variable", currentFunction);
                    } else {
                        // Manejar el error de la lista de parámetros
                        System.err.println("Error: param no es una lista de dos elementos.");
                    }
                }
            } catch (ClassCastException e) {
                // Manejar el error de casting
                System.err.println("Error: params no es una lista de listas de cadenas.");
            }
        }
    :} RPAREN CUERPO_FUNCION |
    ERRORES_FUNCION  
;

CUERPO_FUNCION ::= 
                LCURLY GLOBAL_DECLARACIONES SENTENCIAS RCURLY|
                LCURLY SENTENCIAS RCURLY |
                //error  {: syntaxError(((Symbol) stack.peek()), "Error en las llaves de la función."); :} 
                // LCURLY SENTENCIAS error {: syntaxError(((Symbol) stack.peek()), "Falta la llave de cierre."); :} //falla
                error GLOBAL_DECLARACIONES SENTENCIAS RCURLY {: syntaxError(((Symbol) stack.peek()), "Error en las llaves de la función."); :} 
;           

ERRORES_FUNCION ::= T_DATO IDENTIFIER error CUERPO_FUNCION {: syntaxError(((Symbol) stack.peek()), "Error en los paréntesis de la función."); :} |
                    T_DATO IDENTIFIER error SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Error no se aceptan variables globales"); :} |
                    VOID IDENTIFIER error CUERPO_FUNCION {: syntaxError(((Symbol) stack.peek()), "Error en los paréntesis de la función."); :} |
                    T_DATO IDENTIFIER IDENTIFIER CUERPO_FUNCION {: syntaxError(((Symbol) stack.peek()), "Error en los paréntesis de la función."); :} |
                    VOID IDENTIFIER IDENTIFIER CUERPO_FUNCION {: syntaxError(((Symbol) stack.peek()), "Error en los paréntesis de la función."); :} |
                    IDENTIFIER LPAREN PARAMETROS RPAREN CUERPO_FUNCION {: syntaxError(((Symbol) stack.peek()), "Falta el tipo de dato en la declaración de la función."); :} |
                    IDENTIFIER LPAREN RPAREN CUERPO_FUNCION {: syntaxError(((Symbol) stack.peek()), "Falta el tipo de dato en la declaración de la función."); :} 
;


PARAMETROS ::= 
    T_DATO:type IDENTIFIER:id {:
        List<List<String>> params = new ArrayList<>();
        List<String> param = new ArrayList<>();
        param.add((String) type);
        param.add((String) id);
        params.add(param);
        RESULT = params;
    :} |
    PARAMETROS:params COMMA T_DATO:type IDENTIFIER:id {:
        List<String> param = new ArrayList<>();
        param.add((String) type);
        param.add((String) id);
        ((List<List<String>>) params).add(param);
        RESULT = params;
    :} |
    error IDENTIFIER {: syntaxError(((Symbol) stack.peek()), "Falta el tipo de dato en el parámetro."); :} |
    T_DATO {: syntaxError(((Symbol) stack.peek()), "El parámetro debe tener un identificador."); :} | 
    PARAMETROS COMMA T_DATO {: syntaxError(((Symbol) stack.peek()), "El parámetro debe tener un identificador."); :} |
    PARAMETROS COMMA error {: syntaxError(((Symbol) stack.peek()), "Error en la coma de los parametros."); :}
;

SENTENCIAS ::=
    SENTENCIAS SENTENCIA | 
;

SENTENCIA ::= 
    ESTRUCTURA_IF |
    DO_WHILE |
    ESTRUCTURA_WHILE |
    ESTRUCTURA_FOR |
    READ_WRITE |
    CONTROL_STATEMENT|
    SWITCHs |
    EXPRESIONES SEMICOLON |
    EXPRESIONES {: syntaxError(((Symbol) stack.peek()), "Falta punto y coma."); :}
;

CONTROL_STATEMENT ::= 
    BREAK SEMICOLON {:
        RS rs_while = pilaSemantica.searchContext("while");
        if (rs_while == null) {
            System.out.println("Error semántico en la linea "+ ((Symbol) stack.peek()).left +": break fuera de una estructura iterativa.");
        } else {
            code += "JMP " + rs_while.getLabel(1) + "\n";
        }
    :}|
    CONTINUE SEMICOLON {:
        RS rs_while = pilaSemantica.searchContext("while");
        if (rs_while == null) {
            System.out.println("Error semántico en la linea "+ ((Symbol) stack.peek()).left +": continue fuera de una estructura iterativa.");
        } else {
            code += "JMP " + rs_while.getLabel(0) + "\n";
        }
    :}|
    RETURN SEMICOLON |
    RETURN EXPRESION_ARITMETICA SEMICOLON|
    BREAK {: syntaxError(((Symbol) stack.peek()), "Falta punto y coma."); :} |
    CONTINUE {: syntaxError(((Symbol) stack.peek()), "Falta punto y coma."); :} |
    RETURN EXPRESION_ARITMETICA {: syntaxError(((Symbol) stack.peek()), "Falta punto y coma."); :} |
    RETURN error {: syntaxError(((Symbol) stack.peek()), "Falta punto y coma."); :} 
;

DECLARACION ::= 
    T_DATO:id_type ID_LIST:id_list SEMICOLON {:
        String context = isGlobal ? "global" : "local";
        if (id_list instanceof List<?>) {
            String categoria = "variable";
            try {
                for (String id : (List<String>) id_list) {
                    RS nuevoSimbolo = new RS((String) id, (String) id_type);
                    pilaSemanticaVar.push(nuevoSimbolo);

                    RS simbolo = pilaSemanticaVar.pop();
                    symbolTable.addVar(simbolo.getValue(), simbolo.getType(), context, ((Symbol) stack.peek()).left, categoria, currentFunction);
                }
                
            } catch (ClassCastException e) {
                // Manejar el error de casting
                System.err.println("Error: id_list no es una lista de cadenas.");
            }
        } else if (id_list instanceof String) {
            String categoria = "variable";
            for (String id : (List<String>) id_list) {
                    RS nuevoSimbolo = new RS((String) id, (String) id_type);
                    pilaSemanticaVar.push(nuevoSimbolo);
                    RS simbolo = pilaSemanticaVar.pop();
                    symbolTable.addVar(simbolo.getValue(), simbolo.getType(), context, ((Symbol) stack.peek()).left, categoria, currentFunction);
                }
                
        } else {
            // Manejar el caso donde id_list no es ni una lista ni una cadena
            System.err.println("Error: id_list no es una instancia de List ni de String.");
        }
    :} | 
    CONST T_DATO:id_type ID_LIST:id_list SEMICOLON {:
    String context = isGlobal ? "global" : "local";
        if (id_list instanceof List<?>) {
            String categoria = "constante";
            try {
                
                for (String id : (List<String>) id_list) {
                    RS nuevoSimbolo = new RS((String) id, (String) id_type);
                    pilaSemanticaVar.push(nuevoSimbolo);
                    

                    //symbolTable.addVar(id, (String) id_type, context, ((Symbol) stack.peek()).left, currentFunction);
                
                    RS simbolo = pilaSemanticaVar.pop();
                    symbolTable.addVar(simbolo.getValue(), simbolo.getType(), context, ((Symbol) stack.peek()).left, categoria, currentFunction);
                }
            } catch (ClassCastException e) {
                // Manejar el error de casting
                System.err.println("Error: id_list no es una lista de cadenas.");
            }
        } else if (id_list instanceof String) {
            String categoria = "constante";
            for (String id : (List<String>) id_list) {
                    RS nuevoSimbolo = new RS((String) id, (String) id_type);
                    pilaSemanticaVar.push(nuevoSimbolo);
                
                    RS simbolo = pilaSemanticaVar.pop();
                    symbolTable.addVar(simbolo.getValue(), simbolo.getType(), context, ((Symbol) stack.peek()).left, categoria, currentFunction);
                }
        } else {
            // Manejar el caso donde id_list no es ni una lista ni una cadena
            System.err.println("Error: id_list no es una instancia de List ni de String.");
        }
    
    
    :}|
    VOID ID_LIST SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Una variable no puede ser declarada void."); :} |
    T_DATO SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Falta el identificador de la variable en la declaración."); :} |
    T_DATO error {: syntaxError(((Symbol) stack.peek()), "Falta punto y coma."); :} |
    error ID_LIST SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Falta el tipo de dato en la declaración."); :} |
    CONST T_DATO SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Falta el identificador de la variable en la declaración."); :} 
;

ID_LIST ::= IDENTIFIER:id {:
                List<String> ids = new ArrayList<>();
                ids.add((String) id);
                RESULT = ids;
            :}
            |
            ID_LIST:id_list COMMA IDENTIFIER:id {:
                ((List<String>) id_list).add((String) id);
                RESULT = id_list;
            :}
            |
            ID_LIST:id_list COMMA IDENTIFIER:id ASSIGN EXPRESIONES_LOGICAS {:
                ((List<String>) id_list).add((String) id);
                RESULT = id_list;
            :}
            |
            IDENTIFIER:id ASSIGN EXPRESIONES_LOGICAS {:
                //System.out.println("Identificador: " + id);
                RESULT = id;
            :}
            
            // ID_LIST error IDENTIFIER {: syntaxError(((Symbol) stack.peek()), "Falta coma entre identificadores."); :} |  //hacen que el assing falle
            // ID_LIST error IDENTIFIER ASSIGN EXPRESIONES_LOGICAS {: syntaxError(((Symbol) stack.peek()), "Falta coma entre identificadores."); :} |
            // ID_LIST COMMA IDENTIFIER ASSIGN error {: syntaxError(((Symbol) stack.peek()), "No se asignó ningun valor a la variable"); :} |
            // IDENTIFIER ASSIGN error {: syntaxError(((Symbol) stack.peek()), "No se asignó ningun valor a la variable"); :}
;

ESTRUCTURA_IF ::= IF INICIO_IF EXPRESIONES:e FIN_CONDICION_IF CUERPO_IF ESTRUCTURA_ELSE |
    
    IF LPAREN EXPRESIONES RPAREN LCURLY SENTENCIAS RCURLY |
    ERRORES_IF
;


INICIO_IF ::= LPAREN {:
    String labelIf = labelGenerator.generateLabel();  
    String labelElse = labelGenerator.generateLabel(); 
    String exitLabel = labelGenerator.generateLabel();

    code += labelIf + ":\n";
    RS rs_if = new RS("if", "if");
    rs_if.addLabel(labelIf);  
    rs_if.addLabel(labelElse); 
    rs_if.addLabel(exitLabel); 
    pilaSemantica.push(rs_if);
:}| error {: syntaxError(((Symbol) stack.peek()), "Falta paréntesis de apertura en el if."); :} ;


FIN_CONDICION_IF ::= RPAREN {:
    RS rsD0 = pilaSemantica.pop();
    RS rs_if = pilaSemantica.peek();
    String elseLabel = rs_if.getLabel(1);
    String op = rsD0.getValue();
    if (op.equals("==")) {
        code += "JNE " + elseLabel + "\n";  
    } else if (op.equals("!=")) {
        code += "JE " + elseLabel + "\n";
    } else if (op.equals("<")) {
        code += "JGE " + elseLabel + "\n";
    } else if (op.equals(">")) {
        code += "JLE " + elseLabel + "\n";
    }
:}| error {: syntaxError(((Symbol) stack.peek()), "Falta paréntesis de cierre en el if."); :} ;

CUERPO_IF ::= INICIO_SENTENCIA_IF SENTENCIAS:e CIERRE_SENTENCIA_IF {:
    RS rs_if = pilaSemantica.peek();
    String exitLabel = rs_if.getLabel(2); 
    code += "JMP " + exitLabel + "\n"; 
    code += rs_if.getLabel(1) + ":\n"; 
:};

INICIO_SENTENCIA_IF ::= LCURLY | {: syntaxError(((Symbol) stack.peek()), "Falta llave de apertura en el while."); :} ;

CIERRE_SENTENCIA_IF ::= RCURLY;

ERRORES_IF ::=
    IF LPAREN error RPAREN LCURLY SENTENCIAS RCURLY ESTRUCTURA_ELSE {: syntaxError(((Symbol) stack.peek()), "Error en la condición del if."); :} |
    IF LPAREN error RPAREN LCURLY SENTENCIAS RCURLY {: syntaxError(((Symbol) stack.peek()), "Error en la condición del if."); :} |
    IF error RPAREN LCURLY SENTENCIAS RCURLY ESTRUCTURA_ELSE {: syntaxError(((Symbol) stack.peek()), "Falta paréntesis de apertura en el if."); :} |
    IF error RPAREN LCURLY SENTENCIAS RCURLY {: syntaxError(((Symbol) stack.peek()), "Falta paréntesis de apertura en el if."); :} |
    IF LPAREN EXPRESIONES LCURLY SENTENCIAS RCURLY ESTRUCTURA_ELSE {: syntaxError(((Symbol) stack.peek()), "Error en el paréntesis de cierre del if."); :} |
    IF LPAREN EXPRESIONES LCURLY SENTENCIAS RCURLY {: syntaxError(((Symbol) stack.peek()), "Error en el paréntesis de cierre del if."); :} |
    IF LPAREN LCURLY SENTENCIAS RCURLY ESTRUCTURA_ELSE {: syntaxError(((Symbol) stack.peek()), "Error en el paréntesis de cierre del if."); :} |
    IF LPAREN LCURLY SENTENCIAS RCURLY {: syntaxError(((Symbol) stack.peek()), "Error en el paréntesis de cierre del if."); :} |
    IF error LCURLY SENTENCIAS RCURLY ESTRUCTURA_ELSE {: syntaxError(((Symbol) stack.peek()), "Error en los paréntesis de la condición del if."); :} | 
    IF error LCURLY SENTENCIAS RCURLY {: syntaxError(((Symbol) stack.peek()), "Error en los paréntesis de la condición del if."); :} |
    IF LPAREN EXPRESIONES RPAREN error SENTENCIAS RCURLY ESTRUCTURA_ELSE {: syntaxError(((Symbol) stack.peek()), "Error en la llave de apertura del if."); :} |
    IF LPAREN EXPRESIONES RPAREN error SENTENCIAS RCURLY {: syntaxError(((Symbol) stack.peek()), "Error en la llave de apertura del if."); :}
;

EXPRESIONES ::= 
    EXPRESION_ASIGNACION |
    EXPRESIONES_LOGICAS:e {: RESULT = e; :}
;

EXPRESIONES_LOGICAS ::=
    EXPRESIONES_LOGICAS:e1 OP_LOGICOS:op EXPRESIONES_RELACIONAL:e2 {::}|
    EXPRESIONES_RELACIONAL:e {: RESULT = e; :}
;

EXPRESIONES_RELACIONAL ::= 
    EXPRESIONES_RELACIONAL:e1 OP_RELACIONALES:op EXPRESION_ARITMETICA:e2 {:
        if (e1 != null && e2 != null) {
            String e1Code = "";
            if (((RS) e2).getType() == "register") {
                code += "POP EBX\n";
            }
            if (((RS) e1).getType() == "const") {
                e1Code = "MOV EAX, " + ((RS) e1).getValue();
            } else if (((RS) e1).getType() == "register") {
                e1Code = "POP EAX";
            } else {
                e1Code = "MOV EAX, [" + ((RS) e1).getValue() + "]";
            }
            String e2Code = "";
            if (((RS) e2).getType() == "const") {
                e2Code = ((RS) e2).getValue();
            } else if (((RS) e2).getType() == "register") {
                e2Code = "EBX";
            } else {
                e2Code = "[" + ((RS) e2).getValue() + "]";
            }
            code += e1Code + "\nCMP EAX, " + e2Code + "\n";
            RS res = new RS(String.valueOf(op), "op");
            pilaSemantica.push(res);
            RESULT = res;
        }
    :}
    |
    EXPRESION_ARITMETICA:e {: RESULT = e; :}
;

ESTRUCTURA_ELSE ::= 
    ELSE IF LPAREN EXPRESIONES RPAREN LCURLY SENTENCIAS RCURLY ESTRUCTURA_ELSE |
    ELSE IF LPAREN EXPRESIONES RPAREN LCURLY SENTENCIAS RCURLY |
    ELSE LCURLY SENTENCIAS:e RCURLY {:
    RS rs_if = pilaSemantica.pop();
    String exitLabel = rs_if.getLabel(2);
    code += "JMP " + exitLabel + "\n";
    code += rs_if.getLabel(2) + ":\n";
    :}|
    ELSE LCURLY SENTENCIAS RCURLY ESTRUCTURA_ELSE {: syntaxError(((Symbol) stack.peek()), "Múltiples else en estructura if."); :} |
    ELSE error SENTENCIAS RCURLY {: syntaxError(((Symbol) stack.peek()), "Error en la llave de apertura del else."); :} |
    ELSE ERRORES_IF
;

ESTRUCTURA_WHILE ::= 
    WHILE INICIO_WHILE EXPRESIONES:e FIN_CONDICION_WHILE CUERPO_WHILE 
;

INICIO_WHILE ::= LPAREN {:
    String label = labelGenerator.generateLabel();
    code += label + ":\n";
    RS rs = new RS("while", "while");
    rs.addLabel(label);
    rs.addLabel(labelGenerator.generateLabel());
    pilaSemantica.push(rs);
:}| error {: syntaxError(((Symbol) stack.peek()), "Falta paréntesis de apertura en el while."); :} ;

FIN_CONDICION_WHILE ::= RPAREN {:
        try {
            RS rsD0 = pilaSemantica.pop();
            String exitLabel = pilaSemantica.peek().getLabel(1);
            String op = rsD0.getValue();
            if (op.equals("==")) {
                code += "JNE " + exitLabel + "\n";
            } else if (op.equals("!=")) {
                code += "JE " + exitLabel + "\n";
            } else if (op.equals("<")) {
                code += "JGE " + exitLabel + "\n";
            } else if (op.equals(">")) {
                code += "JLE " + exitLabel + "\n";
            }
        } catch (Exception e) {
        }
    :}|
    error {: syntaxError(((Symbol) stack.peek()), "Falta paréntesis de cierre en el while."); :} ;

CUERPO_WHILE ::= INICIO_SENTENCIA_WHILE SENTENCIAS CIERRE_SENTENCIA_WHILE{:
    try {
        RS rs_while = pilaSemantica.pop();
        code += "JMP " + rs_while.getLabel(0) + "\n";
        code += rs_while.getLabel(1) + ":\n";
    } catch (Exception e) {
    }
:};

INICIO_SENTENCIA_WHILE ::= LCURLY | {: syntaxError(((Symbol) stack.peek()), "Falta llave de apertura en el while."); :} ;

CIERRE_SENTENCIA_WHILE ::= RCURLY;

DO_WHILE ::= DO LCURLY SENTENCIAS RCURLY WHILE LPAREN EXPRESIONES RPAREN SEMICOLON |
    DO LCURLY SENTENCIAS RCURLY WHILE LPAREN error RPAREN SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Error en la condición del do-while."); :} |
    DO LCURLY SENTENCIAS RCURLY WHILE error RPAREN SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Falta paréntesis de apertura en el do-while."); :} |
    DO LCURLY SENTENCIAS RCURLY WHILE LPAREN EXPRESIONES SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Error en el paréntesis de cierre del do-while."); :} |
    DO LCURLY SENTENCIAS RCURLY WHILE LPAREN SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Error en el paréntesis de cierre del do-while."); :} |
    DO LCURLY SENTENCIAS RCURLY WHILE error SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Error en los paréntesis de la condición del do-while."); :} |
    DO LCURLY SENTENCIAS RCURLY WHILE LPAREN EXPRESIONES RPAREN {: syntaxError(((Symbol) stack.peek()), "Falta punto y coma."); :} |
    DO error SENTENCIAS RCURLY WHILE LPAREN EXPRESIONES RPAREN SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Error en la llave de apertura del do-while."); :} |
    DO LCURLY SENTENCIAS WHILE LPAREN EXPRESIONES RPAREN SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Error en la llave de cierre del do-while."); :} |
    DO LCURLY SENTENCIAS RCURLY LPAREN EXPRESIONES RPAREN SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Falta palabra reservada while antes de la condición."); :} |
    DO error SENTENCIAS WHILE LPAREN EXPRESIONES RPAREN SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Faltan ambas llaves en el do-while."); :} 
;

ESTRUCTURA_FOR ::= FOR LPAREN SENTENCIA_FOR RPAREN LCURLY SENTENCIAS RCURLY |
    FOR LPAREN error RPAREN LCURLY SENTENCIAS RCURLY {: syntaxError(((Symbol) stack.peek()), "Error en la sentencia del for."); :} |
    FOR error RPAREN LCURLY SENTENCIAS RCURLY {: syntaxError(((Symbol) stack.peek()), "Falta paréntesis de apertura en el for."); :} |
    FOR LPAREN SENTENCIA_FOR LCURLY SENTENCIAS RCURLY {: syntaxError(((Symbol) stack.peek()), "Error en el paréntesis de cierre del for."); :} |
    FOR LPAREN LCURLY SENTENCIAS RCURLY {: syntaxError(((Symbol) stack.peek()), "Error en el paréntesis de cierre del for."); :} |
    FOR error LCURLY SENTENCIAS RCURLY {: syntaxError(((Symbol) stack.peek()), "Error en los paréntesis de la condición del for."); :} |
    FOR LPAREN SENTENCIA_FOR RPAREN error SENTENCIAS RCURLY {: syntaxError(((Symbol) stack.peek()), "Error en la llave de apertura del for."); :}
;

SENTENCIA_FOR ::=
    DECLARACION EXPRESION_FOR SEMICOLON EXPRESION_FOR |
    EXPRESION_FOR SEMICOLON EXPRESION_FOR SEMICOLON EXPRESION_FOR |
    EXPRESION_FOR SEMICOLON {: syntaxError(((Symbol) stack.peek()), "No puede haber una sola expresión."); :} 
;

EXPRESION_FOR ::= 
    /* vacío */ |
    EXPRESIONES |
    error {: syntaxError(((Symbol) stack.peek()), "Expresión en `for` incorrecta. Se esperaba una asignación o una condición numérica válida."); :}
;

SWITCHs ::= SWITCH LPAREN EXPRESIONES_NUMERICAS RPAREN LCURLY CASES DEFAULT_STMT CASES RCURLY |
            SWITCH LPAREN EXPRESIONES_NUMERICAS RPAREN LCURLY CASES RCURLY |
            SWITCH LPAREN error RPAREN LCURLY CASES DEFAULT_STMT RCURLY {: syntaxError(((Symbol) stack.peek()), "Error en la condición del switch."); :} |
            SWITCH LPAREN EXPRESIONES_NUMERICAS LCURLY CASES DEFAULT_STMT RCURLY {: syntaxError(((Symbol) stack.peek()), "Error en el paréntesis de cierre del switch."); :} |
            SWITCH LPAREN EXPRESIONES_NUMERICAS RPAREN error CASES DEFAULT_STMT RCURLY {: syntaxError(((Symbol) stack.peek()), "Error en la llave de apertura del switch."); :} |
            SWITCH error RPAREN LCURLY CASES DEFAULT_STMT RCURLY {: syntaxError(((Symbol) stack.peek()), "Falta paréntesis de apertura en el switch."); :} |
            SWITCH LPAREN LCURLY CASES DEFAULT_STMT RCURLY {: syntaxError(((Symbol) stack.peek()), "Error en el paréntesis de cierre del switch."); :} |
            SWITCH error LCURLY CASES DEFAULT_STMT RCURLY {: syntaxError(((Symbol) stack.peek()), "Error en los paréntesis de la condición del switch."); :} |
            SWITCH LPAREN EXPRESIONES_NUMERICAS RPAREN LCURLY CASES DEFAULT_STMT CASES LISTA_DEFAULT CASES RCURLY {: syntaxError(((Symbol) stack.peek()), "Múltiples definiciones de default en un switch."); :} 
;

CASES ::= CASES CASE_STMT |;

CASE_STMT ::= CASE LITERALES COLON SENTENCIAS |
    CASE LITERALES COLON LCURLY SENTENCIAS RCURLY |
    CASE error COLON SENTENCIAS {: syntaxError(((Symbol) stack.elementAt(stack.size() - 2)), "Error en la condición del case."); :} |
    CASE error COLON LCURLY SENTENCIAS RCURLY {: syntaxError(((Symbol) stack.peek()), "Error en la condición del case."); :} |
    CASE LITERALES LCURLY SENTENCIAS RCURLY {: syntaxError(((Symbol) stack.peek()), "Falta dos puntos en el case."); :} |
    CASE LITERALES SENTENCIAS {: syntaxError(((Symbol) stack.elementAt(stack.size() - 2)), "Falta dos puntos en el case."); :}
;

DEFAULT_STMT ::= DEFAULT COLON SENTENCIAS |
    DEFAULT COLON LCURLY SENTENCIAS RCURLY |
    DEFAULT LITERALES COLON SENTENCIAS {: syntaxError(((Symbol) stack.elementAt(stack.size() - 2)), "Default no debe tener literal."); :} |
    DEFAULT LCURLY SENTENCIAS RCURLY {: syntaxError(((Symbol) stack.peek()), "Falta dos puntos en el default."); :} |
    DEFAULT error SENTENCIAS {: syntaxError(((Symbol) stack.elementAt(stack.size() - 2)), "Error en el default."); :} |
    DEFAULT error LCURLY SENTENCIAS RCURLY {: syntaxError(((Symbol) stack.peek()), "Error en el default."); :} 
;

LISTA_DEFAULT ::= DEFAULT_STMT LISTA_DEFAULT | DEFAULT_STMT;

READ_WRITE ::= 
    READ LPAREN IDENTIFIER RPAREN SEMICOLON |
    READ LPAREN RPAREN SEMICOLON |
    WRITE LPAREN LISTA_EXPRESIONES RPAREN SEMICOLON |
    READ error IDENTIFIER RPAREN SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Error en el paréntesis de apertura en la llamada read"); :} |
    READ LPAREN IDENTIFIER error SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Error en la llamada read"); :} |
    READ IDENTIFIER SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Faltan los paréntesis para la llamada read"); :} |
    READ error RPAREN SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Error en el paréntesis de apertura en la llamada read"); :} |
    READ LPAREN error SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Error en la llamada read"); :} |
    WRITE error LISTA_EXPRESIONES RPAREN SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Error en el paréntesis de apertura en la llamada write"); :} | 
    WRITE LPAREN LISTA_EXPRESIONES error SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Error en el paréntesis de cierre en la llamada write"); :} | //hay un error porque es como si siguiera como entre LISTA_EXPRESIONES porque no sabe bien cuando parar
    READ LPAREN IDENTIFIER RPAREN {: syntaxError(((Symbol) stack.peek()), "Falta punto y coma."); :}  |
    READ LPAREN RPAREN {: syntaxError(((Symbol) stack.peek()), "Falta punto y coma."); :} |
    WRITE LPAREN LISTA_EXPRESIONES RPAREN {: syntaxError(((Symbol) stack.peek()), "Falta punto y coma."); :} |
    WRITE LPAREN error RPAREN SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Falta una expresión entre los paréntesis"); :} |
    READ SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Falta paréntesis de apertura en la llamada read"); :} |
    WRITE SEMICOLON {: syntaxError(((Symbol) stack.peek()), "Falta paréntesis de apertura en la llamada write"); :} 
;

LISTA_EXPRESIONES ::= EXPRESIONES |
                     LISTA_EXPRESIONES COMMA EXPRESIONES |
                     LISTA_EXPRESIONES COMMA error {: syntaxError(((Symbol) stack.peek()), "Falta expresión después de la coma."); :} |
                     COMMA EXPRESIONES {: syntaxError(((Symbol) stack.peek()), "Falta expresión antes de la coma."); :} |
                     LISTA_EXPRESIONES error {: syntaxError(((Symbol) stack.peek()), "Falta coma entre expresiones."); :} 
;

T_DATO ::= 
    INT {: RESULT = "int"; :} |
    CHAR {: RESULT = "char"; :} |
    LONG {: RESULT = "long"; :} |
    SHORT {: RESULT = "short"; :} |
    INT LONG {: RESULT = "int long"; :} |
    INT SHORT {: RESULT = "int short"; :} |
    LONG INT {: RESULT = "long int"; :} |
    SHORT INT {: RESULT = "short int"; :}
;
OP_RELACIONALES ::= 
    EQ_OP:e {:
        RESULT = e ;
    :}|
    NE_OP:e {:
        RESULT = e;
    :}|
    LT_OP:e {:
        RESULT = e;
    :}|
    GT_OP:e {:
        RESULT = e;
    :}| 
    LE_OP:e {:
        RESULT = e;
    :}| 
    GE_OP:e {:
        RESULT = e;
    :};
OP_LOGICOS ::= 
    OR_OP:e {:
        RESULT = e;
    :} | 
    AND_OP:e {:
        RESULT = e;
    :} | 
    NOT_OP:e {:
        RESULT = e; 
    :};
OP_ARITMETICOS ::= PLUS | MINUS | TIMES | DIVIDE | MOD | INC_OP | DEC_OP | PLUS_ASSIGN | MINUS_ASSIGN | TIMES_ASSIGN | DIV_ASSIGN;
LITERALES ::= 
    NUMBER:e {: 
        RESULT = e;
    :}| 
    CHAR_LITERAL:e {:
        RESULT = e;
    :}| HEX_LITERAL:e {:
        RESULT = e;
    :}| OCTAL_LITERAL:e {:
        RESULT = e;
    :}| BINARY_LITERAL:e {:
        RESULT = e;
    :}
;

ARGUMENTOS ::= EXPRESIONES_LOGICAS |
               ARGUMENTOS COMMA EXPRESIONES_LOGICAS |
               ARGUMENTOS error EXPRESIONES_LOGICAS {: syntaxError(((Symbol) stack.peek()), "Falta coma entre argumentos."); :} |
               ARGUMENTOS COMMA error {: syntaxError(((Symbol) stack.peek()), "Falta argumento después de la coma."); :} |
               COMMA EXPRESIONES_LOGICAS {: syntaxError(((Symbol) stack.peek()), "falta un argumento antes de la coma." ); :} 
;

EXPRESION_ARITMETICA ::= 
    EXPRESION_ARITMETICA:e1 PLUS EXPRESION_ARITMETICA:e2 {:
        if (e1 != null && e2 != null) {
            if (((RS) e1).getType() == "const" && ((RS) e2).getType() == "const") {
                RESULT = new RS(String.valueOf(Integer.parseInt(((RS) e1).getValue()) + Integer.parseInt(((RS) e2).getValue())), "const");
            } else {
                String newCode = "";
                if (((RS) e2).getType() == "register") {
                    newCode += "POP EBX\n";
                }
                if (((RS) e1).getType() == "const") {
                    newCode += "MOV EAX, " + ((RS) e1).getValue();
                } else if (((RS) e1).getType() == "register") {
                    newCode += "POP EAX";
                } else {
                    newCode += "MOV EAX, [" + ((RS) e1).getValue() + "]"; // e1 is a memory address 
                }
                newCode += "\nADD EAX, ";
                if (((RS) e2).getType() == "const") {
                    newCode += ((RS) e2).getValue();
                } else if (((RS) e2).getType() == "register") {
                    newCode += "EBX";
                } else {
                    newCode += "[" + ((RS) e2).getValue() + "]"; // e2 is a memory address
                }
                newCode = "\nPUSH EAX\n";
                code += newCode;
                RESULT = new RS("", "register");
            }
        }
    :}|
    EXPRESION_ARITMETICA:e1 MINUS EXPRESION_ARITMETICA:e2 {:
        if (e1 != null && e2 != null) {
            if (((RS) e1).getType() == "const" && ((RS) e2).getType() == "const") {
                RESULT = new RS(String.valueOf(Integer.parseInt(((RS) e1).getValue()) - Integer.parseInt(((RS) e2).getValue())), "const");
            } else {
                String newCode = "";
                if (((RS) e2).getType() == "register") {
                    newCode += "POP EBX\n";
                }
                if (((RS) e1).getType() == "const") {
                    newCode += "MOV EAX, " + ((RS) e1).getValue();
                } else if (((RS) e1).getType() == "register") {
                    newCode += "POP EAX";
                } else {
                    newCode += "MOV EAX, [" + ((RS) e1).getValue() + "]"; // e1 is a memory address 
                }
                newCode += "\nSUB EAX, ";
                if (((RS) e2).getType() == "const") {
                    newCode += ((RS) e2).getValue();
                } else if (((RS) e2).getType() == "register") {
                    newCode += "EBX";
                } else {
                    newCode += "[" + ((RS) e2).getValue() + "]"; // e2 is a memory address
                }
                newCode += "\nPUSH EAX\n";
                code += newCode;
                RESULT = new RS("", "register");
            }
        }
    :}|
    EXPRESION_ARITMETICA:e1 TIMES EXPRESION_ARITMETICA:e2 {:
        if(e1 != null && e2 != null) {
            if (((RS) e1).getType() == "const" && ((RS) e2).getType() == "const") {
                RESULT = new RS(String.valueOf(Integer.parseInt(((RS) e1).getValue()) * Integer.parseInt(((RS) e2).getValue())), "const");
            } else {
                String newCode = "";
                if (((RS) e2).getType() == "register") {
                    newCode += "POP EBX\n";
                }
                if (((RS) e1).getType() == "const") {
                    newCode += "MOV EAX, " + ((RS) e1).getValue();
                } else if(((RS) e1).getType() == "register") {
                    newCode += "POP EAX";
                } else {
                    newCode += "MOV EAX, [" + ((RS) e1).getValue() + "]"; // e1 is a memory address 
                }
                newCode += "\nIMUL EAX, ";
                if (((RS) e2).getType() == "const") {
                    newCode += ((RS) e2).getValue();
                } else if(((RS) e2).getType() == "register") {
                    newCode += "EBX";
                } else {
                    newCode += "[" + ((RS) e2).getValue() + "]"; // e2 is a memory address
                }
                newCode += "\nPUSH EAX\n";
                code += newCode;
                RESULT = new RS("", "register");
            }
        }
    :}|
    EXPRESION_ARITMETICA:e1 DIVIDE EXPRESION_ARITMETICA:e2 {:
        if (e1 != null && e2 != null) {
            if (((RS) e1).getType() == "const" && ((RS) e2).getType() == "const") {
                RESULT = new RS(String.valueOf(Integer.parseInt(((RS) e1).getValue()) / Integer.parseInt(((RS) e2).getValue())), "const");
            } else {
                String newCode = "";
                if (((RS) e2).getType() == "register") {
                    newCode += "POP EBX\n";
                }
                if (((RS) e1).getType() == "const") {
                    newCode += "MOV EAX, " + ((RS) e1).getValue();
                } else if(((RS) e1).getType() == "register") {
                    newCode += "POP EAX";
                } else {
                    newCode += "MOV EAX, [" + ((RS) e1).getValue() + "]"; // e1 is a memory address 
                }
                newCode += "\nIDIV EAX, ";
                if (((RS) e2).getType() == "const") {
                    newCode += ((RS) e2).getValue();
                } else if(((RS) e2).getType() == "register") {
                    newCode += "EBX";
                } else {
                    newCode += "[" + ((RS) e2).getValue() + "]"; // e2 is a memory address
                }
                newCode += "\nPUSH EAX\n";
                code += newCode;
                RESULT = new RS("", "register");
            }
        }
    :}|
    EXPRESION_ARITMETICA MOD EXPRESION_ARITMETICA|
    LPAREN EXPRESIONES_LOGICAS:e RPAREN {:
        RESULT = e;
    :}|
    IDENTIFIER:id {:
        if (id != null) {
            if (!symbolTable.varExists((String) id, currentFunction)) {
                System.out.println("Error semántico en la linea "+ ((Symbol) stack.peek()).left +": la variable '" + id + "' no ha sido declarada.");
            }
            else{
                RESULT = new RS(symbolTable.getVarName((String) id), "memory");
            }
        }
    :}|
    IDENTIFIER LPAREN ARGUMENTOS RPAREN |
    IDENTIFIER LPAREN RPAREN |
    LITERALES:l {:
        if (l != null) {
            RESULT = new RS(String.valueOf(l), "const");
        }
    :}|
    INCREMENTO_DECREMENTO:e {:
        RESULT = e;
    :}|
    EXPRESION_ARITMETICA PLUS error {: syntaxError(((Symbol) stack.peek()), "Error en la expresión"); :} |
    EXPRESION_ARITMETICA MINUS error {: syntaxError(((Symbol) stack.peek()), "Error en la expresión"); :} |
    EXPRESION_ARITMETICA TIMES error {: syntaxError(((Symbol) stack.peek()), "Error en la expresión"); :} |
    EXPRESION_ARITMETICA DIVIDE error {: syntaxError(((Symbol) stack.peek()), "Error en la expresión"); :} |
    EXPRESION_ARITMETICA MOD error {: syntaxError(((Symbol) stack.peek()), "Error en la expresión"); :} |
    LPAREN error RPAREN {: syntaxError(((Symbol) stack.peek()), "Expresión inválida dentro de paréntesis."); :} |
    TIMES EXPRESION_ARITMETICA {: syntaxError(((Symbol) stack.peek()), "Falta operando antes de '*'."); :} |
    DIVIDE EXPRESION_ARITMETICA {: syntaxError(((Symbol) stack.peek()), "Falta operando antes de '/'."); :} |
    PLUS EXPRESION_ARITMETICA {: syntaxError(((Symbol) stack.peek()), "Falta operando antes de '+'."); :} |
    MINUS EXPRESION_ARITMETICA {: syntaxError(((Symbol) stack.peek()), "Falta operando antes de '-'."); :} |
    LPAREN error {: syntaxError(((Symbol) stack.peek()), "Error en paréntesis de expresión."); :}
;


EXPRESIONES_NUMERICAS ::= 
    EXPRESIONES_NUMERICAS:e1 PLUS EXPRESIONES_NUMERICAS:e2 {:
        if(e1 != null && e2 != null) {
            if (((RS) e1).getType() == "const" && ((RS) e2).getType() == "const") {
                RESULT = new RS(String.valueOf(Integer.parseInt(((RS) e1).getValue()) + Integer.parseInt(((RS) e2).getValue())), "const");
            } else {
                String newCode = "";
                if (((RS) e2).getType() == "register") {
                    newCode += "POP EBX\n";
                }
                if (((RS) e1).getType() == "const") {
                    newCode += "MOV EAX, " + ((RS) e1).getValue();
                } else if(((RS) e1).getType() == "register") {
                    newCode += "POP EAX";
                } else {
                    newCode += "MOV EAX, [" + ((RS) e1).getValue() + "]"; // e1 is a memory address 
                }
                code += "\nADD EAX, ";
                if (((RS) e2).getType() == "const") {
                    newCode += ((RS) e2).getValue();
                } else if(((RS) e2).getType() == "register") {
                    newCode += "EBX";
                }
                else {
                    newCode += "[" + ((RS) e2).getValue() + "]"; // e2 is a memory address
                }
                newCode += "\nPUSH EAX\n";
                code += newCode;
                RESULT = new RS("", "register");
            }
        }
    :}|
    EXPRESIONES_NUMERICAS:e1 MINUS EXPRESIONES_NUMERICAS:e2 {:
        if(e1 != null && e2 != null) {
            if (((RS) e1).getType() == "const" && ((RS) e2).getType() == "const") {
                RESULT = new RS(String.valueOf(Integer.parseInt(((RS) e1).getValue()) - Integer.parseInt(((RS) e2).getValue())), "const");
            } else {
                String newCode = "";
                if (((RS) e2).getType() == "register") {
                    newCode += "POP EBX\n";
                }
                if (((RS) e1).getType() == "const") {
                    newCode += "MOV EAX, " + ((RS) e1).getValue();
                } else if(((RS) e1).getType() == "register") {
                    newCode += "POP EAX";
                } else {
                    newCode += "MOV EAX, [" + ((RS) e1).getValue() + "]"; // e1 is a memory address 
                }
                newCode += "\nSUB EAX, ";
                if (((RS) e2).getType() == "const") {
                    newCode += ((RS) e2).getValue();
                } else if(((RS) e2).getType() == "register") {
                    newCode += "EBX";
                } else {
                    newCode += "[" + ((RS) e2).getValue() + "]"; // e2 is a memory address
                }
                newCode += "\nPUSH EAX\n";
                code += newCode;
                RESULT = new RS("", "register");
            }
        }
    :}|
    EXPRESIONES_NUMERICAS:e1 TIMES EXPRESIONES_NUMERICAS:e2 {:
        if(e1 != null && e2 != null) {
            if (((RS) e1).getType() == "const" && ((RS) e2).getType() == "const") {
                RESULT = new RS(String.valueOf(Integer.parseInt(((RS) e1).getValue()) * Integer.parseInt(((RS) e2).getValue())), "const");
            } else {
                String newCode = "";
                if (((RS) e2).getType() == "register") {
                    newCode += "POP EBX\n";
                }
                if (((RS) e1).getType() == "const") {
                    newCode += "MOV EAX, " + ((RS) e1).getValue();
                } else if (((RS) e1).getType() == "register") {
                    newCode += "POP EAX";
                } else {
                    newCode += "MOV EAX, [" + ((RS) e1).getValue() + "]"; // e1 is a memory address 
                }
                newCode += "\nIMUL EAX, ";
                if (((RS) e2).getType() == "const") {
                    newCode += ((RS) e2).getValue();
                } else if(((RS) e2).getType() == "register") {
                    newCode += "EBX";
                } else {
                    newCode += "[" + ((RS) e2).getValue() + "]"; // e2 is a memory address
                }
                newCode += "\nPUSH EAX\n";
                code += newCode;
                RESULT = new RS("", "register");
            }
        }
    :}|
    EXPRESIONES_NUMERICAS:e1 DIVIDE EXPRESIONES_NUMERICAS:e2 {:
        if(e1 != null && e2 != null) {
            if (((RS) e1).getType() == "const" && ((RS) e2).getType() == "const") {
                RESULT = new RS(String.valueOf(Integer.parseInt(((RS) e1).getValue()) / Integer.parseInt(((RS) e2).getValue())), "const");
            } else {
                String newCode = "";
                if (((RS) e2).getType() == "register") {
                    newCode += "POP EBX\n";
                }
                if (((RS) e1).getType() == "const") {
                    newCode += "MOV EAX, " + ((RS) e1).getValue();
                } if (((RS) e1).getType() == "register") {
                    newCode += "POP EAX";
                } else {
                    newCode += "MOV EAX, [" + ((RS) e1).getValue() + "]"; // e1 is a memory address 
                }
                newCode += "\nIDIV EAX, ";
                if (((RS) e2).getType() == "const") {
                    newCode += ((RS) e2).getValue();
                } else if(((RS) e2).getType() == "register") {
                    newCode += "EBX";
                } else {
                    newCode += "[" + ((RS) e2).getValue() + "]"; // e2 is a memory address
                }
                newCode += "\nPUSH EAX\n";
                code += newCode;
                RESULT = new RS("", "register");
            }
        }
    :}|
    EXPRESIONES_NUMERICAS MOD EXPRESIONES_NUMERICAS |
    LPAREN EXPRESIONES_NUMERICAS:e RPAREN {:
        RESULT = e;
    :}|
    IDENTIFIER:id {:
        if(id != null) {
            if (!symbolTable.varExists((String) id, currentFunction)) {
                System.out.println("Error semántico en la linea "+ ((Symbol) stack.peek()).left +": la variable '" + id + "' no ha sido declarada.");
            }
            else{
                RESULT = new RS(symbolTable.getVarName((String) id), "memory");
            }
        }
    :}|
    IDENTIFIER LPAREN ARGUMENTOS RPAREN |
    IDENTIFIER LPAREN RPAREN |
    LITERALES:l {:
        if (l != null) {
            RESULT = new RS(String.valueOf(l), "const");
        }
    :}|
    INCREMENTO_DECREMENTO:e {:
        RESULT = e;
    :}|
    EXPRESIONES_NUMERICAS PLUS error {: syntaxError(((Symbol) stack.peek()), "Falta operando después de '+'."); :} |
    EXPRESIONES_NUMERICAS MINUS error {: syntaxError(((Symbol) stack.peek()), "Falta operando después de '-'."); :} |
    EXPRESIONES_NUMERICAS TIMES error {: syntaxError(((Symbol) stack.peek()), "Falta operando después de '*'."); :} |
    EXPRESIONES_NUMERICAS DIVIDE error {: syntaxError(((Symbol) stack.peek()), "Falta operando después de '/'."); :} |
    EXPRESIONES_NUMERICAS MOD error {: syntaxError(((Symbol) stack.peek()), "Falta operando después de '%'."); :} |
    error PLUS EXPRESIONES_NUMERICAS {: syntaxError(((Symbol) stack.peek()), "Falta operando antes de '+'."); :} |
    error MINUS EXPRESIONES_NUMERICAS {: syntaxError(((Symbol) stack.peek()), "Falta operando antes de '-'."); :} |
    error TIMES EXPRESIONES_NUMERICAS {: syntaxError(((Symbol) stack.peek()), "Falta operando antes de '*'."); :} |
    error DIVIDE EXPRESIONES_NUMERICAS {: syntaxError(((Symbol) stack.peek()), "Falta operando antes de '/'."); :} |
    error MOD EXPRESIONES_NUMERICAS {: syntaxError(((Symbol) stack.peek()), "Falta operando antes de '%'."); :} |
    LPAREN error RPAREN {: syntaxError(((Symbol) stack.peek()), "Expresión inválida dentro de paréntesis."); :}
;

INCREMENTO_DECREMENTO ::= 
    IDENTIFIER:id INC_OP {:
        if (id != null){
            if (!symbolTable.varExists((String) id, currentFunction)) {
                System.out.println("Error semántico en la linea "+ ((Symbol) stack.peek()).left +": la variable '" + id + "' no ha sido declarada.");
            }
            else{
                code += "INC [" + symbolTable.getVarName((String) id) + "]\n";
                RESULT = new RS((String) id, "memory");
            }
        }
    :}|
    IDENTIFIER:id DEC_OP {:
        if (id != null) {
            if (!symbolTable.varExists((String) id, currentFunction)) {
                System.out.println("Error semántico en la linea "+ ((Symbol) stack.peek()).left +": la variable '" + id + "' no ha sido declarada.");
            }
            else{
                code += "DEC [" + symbolTable.getVarName((String) id) + "]\n";
                RESULT = new RS((String) id, "memory");
            }
        }
    :}| 
    INC_OP IDENTIFIER:id {:
        if (id != null) {
            if (!symbolTable.varExists((String) id, currentFunction)) {
                System.out.println("Error semántico en la linea "+ ((Symbol) stack.peek()).left +": la variable '" + id + "' no ha sido declarada.");
            }
            else{
                code += "INC [" + symbolTable.getVarName((String) id) + "]\n";
                RESULT = new RS((String) id, "memory");
            }
        }
    :}| 
    DEC_OP IDENTIFIER:id {:
        if (id != null) {
            if (!symbolTable.varExists((String) id, currentFunction)) {
                System.out.println("Error semántico en la linea "+ ((Symbol) stack.peek()).left +": la variable '" + id + "' no ha sido declarada.");
            }
            else{
                code += "DEC [" + symbolTable.getVarName((String) id) + "]\n";
                RESULT = new RS((String) id, "memory");
            }
        }
    :}|
    DEC_OP error {: syntaxError(((Symbol) stack.peek()), "Falta el identificador antes o despues de '--'."); :} |
    INC_OP error {: syntaxError(((Symbol) stack.peek()), "Falta el identificador antes o despues de '++'."); :}    
;

EXPRESION_ASIGNACION ::= 
    IDENTIFIER:id PLUS_ASSIGN EXPRESIONES_LOGICAS:e {:
        if (id != null && e != null) {
            if (!symbolTable.varExists((String) id, currentFunction)) {
                System.out.println("Error semántico en la linea "+ ((Symbol) stack.peek()).left +": la variable '" + id + "' no ha sido declarada.");
            }
            else{
                String newCode = "ADD [" + (String) id + "]";
                if (((RS) e).getType() == "const") {
                    newCode += ", " + ((RS) e).getValue() + "\n";
                } else if (((RS) e).getType() == "register") {
                    newCode = "POP EAX\n" + newCode + ", EAX\n";
                } else {
                    newCode = "MOV EAX, [" + symbolTable.getVarName(((RS) e).getValue()) + "]\n" + newCode + ", EAX\n";
                }
                code += newCode;
                RESULT = new RS((String) id, "memory");
            }
        }
    :}|
    IDENTIFIER:id MINUS_ASSIGN EXPRESIONES_LOGICAS:e {:
        if (id != null && e != null) {
            if (!symbolTable.varExists((String) id, currentFunction)) {
                System.out.println("Error semántico en la linea "+ ((Symbol) stack.peek()).left +": la variable '" + id + "' no ha sido declarada.");
            }
            else{
                String newCode = "SUB [" + (String) id + "]";
                if (((RS) e).getType() == "const") {
                    newCode += ", " + ((RS) e).getValue() + "\n";
                } else if (((RS) e).getType() == "register") {
                    newCode = "POP EAX\n" + newCode + ", EAX\n";
                } else {
                    newCode = "MOV EAX, [" + symbolTable.getVarName(((RS) e).getValue()) + "]\n" + newCode + ", EAX\n";
                }
                code += newCode;
                RESULT = new RS((String) id, "memory");
            }
        }
    :}|
    IDENTIFIER:id TIMES_ASSIGN EXPRESIONES_LOGICAS:e {:
        if (id != null && e != null) {
            if (!symbolTable.varExists((String) id, currentFunction)) {
                System.out.println("Error semántico en la linea "+ ((Symbol) stack.peek()).left +": la variable '" + id + "' no ha sido declarada.");
            }
            else{
                String newCode = "IMUL [" + (String) id + "]";
                if (((RS) e).getType() == "const") {
                    newCode += ", " + ((RS) e).getValue() + "\n";
                } else if (((RS) e).getType() == "register") {
                    newCode = "POP EAX\n" + newCode + ", EAX\n";
                } else {
                    newCode = "MOV EAX, [" + symbolTable.getVarName(((RS) e).getValue()) + "]\n" + newCode + ", EAX\n";
                }
                code += newCode;
                RESULT = new RS((String) id, "memory");
            }
        }
    :}|
    IDENTIFIER:id DIV_ASSIGN EXPRESIONES_LOGICAS:e {:
        if (id != null && e != null) {
            if (!symbolTable.varExists((String) id, currentFunction)) {
                System.out.println("Error semántico en la linea "+ ((Symbol) stack.peek()).left +": la variable '" + id + "' no ha sido declarada.");
            }
            else{
                String newCode = "IDIV [" + (String) id + "]";
                if (((RS) e).getType() == "const") {
                    newCode += ", " + ((RS) e).getValue() + "\n";
                } else if (((RS) e).getType() == "register") {
                    newCode = "POP EAX\n" + newCode + ", EAX\n";
                } else {
                    newCode = "MOV EAX, [" + symbolTable.getVarName(((RS) e).getValue()) + "]\n" + newCode + ", EAX\n";
                }
                code += newCode;
                RESULT = new RS((String) id, "memory");
            }
        }
    :}|
    IDENTIFIER:id ASSIGN EXPRESIONES_LOGICAS:e {:
        if (id != null && e != null) {
            if (!symbolTable.varExists((String) id, currentFunction)) {
                System.out.println("Error semántico en la linea "+ ((Symbol) stack.peek()).left +": la variable '" + id + "' no ha sido declarada.");
            }
            else{
                String newCode = "MOV [" + (String) id + "]";
                if (((RS) e).getType() == "const") {
                    newCode += ", " + ((RS) e).getValue() + "\n";
                } else if (((RS) e).getType() == "register") {
                    newCode = "POP EAX\n" + newCode + ", EAX\n";
                } else {
                    newCode = "MOV EAX, [" + symbolTable.getVarName(((RS) e).getValue()) + "]\n" + newCode + ", EAX\n";
                }
                code += newCode;
                RESULT = new RS((String) id, "memory");
            }
        }
    :}|
    IDENTIFIER:id ASSIGN EXPRESION_ASIGNACION:e {:
        if (id != null && e != null) {
            if(!symbolTable.varExists((String) id, currentFunction)) {
                System.out.println("Error semántico en la linea "+ ((Symbol) stack.peek()).left +": la variable '" + id + "' no ha sido declarada.");
            }
            else {
                String newCode = "MOV [" + (String) id + "]";
                if (((RS) e).getType() == "const") {
                    newCode += ", " + ((RS) e).getValue() + "\n";
                } else if (((RS) e).getType() == "register") {
                    newCode = "POP EAX\n" + newCode + ", EAX\n";
                } else {
                    newCode = "MOV EAX, [" + symbolTable.getVarName(((RS) e).getValue()) + "]\n" + newCode + ", EAX\n";
                }
                code += newCode;
                RESULT = new RS((String) id, "memory");
            }
        }
    :}|
    IDENTIFIER PLUS_ASSIGN error {: syntaxError(((Symbol) stack.peek()), "Expresión inválida después de '+=' en asignación compuesta."); :} |
    IDENTIFIER MINUS_ASSIGN error {: syntaxError(((Symbol) stack.peek()), "Expresión inválida después de '-=' en asignación compuesta."); :} |
    IDENTIFIER TIMES_ASSIGN error {: syntaxError(((Symbol) stack.peek()), "Expresión inválida después de '*=' en asignación compuesta."); :} |
    IDENTIFIER DIV_ASSIGN error {: syntaxError(((Symbol) stack.peek()), "Expresión inválida después de '/=' en asignación compuesta."); :} |
    IDENTIFIER ASSIGN error {: syntaxError(((Symbol) stack.peek()), "Expresión inválida después de '=' en asignación."); :} |
    PLUS_ASSIGN EXPRESIONES_LOGICAS {: syntaxError(((Symbol) stack.peek()), "Falta el identificador antes de '+='."); :} |
    MINUS_ASSIGN EXPRESIONES_LOGICAS {: syntaxError(((Symbol) stack.peek()), "Falta el identificador antes de '-='."); :} |
    TIMES_ASSIGN EXPRESIONES_LOGICAS {: syntaxError(((Symbol) stack.peek()), "Falta el identificador antes de '*='."); :} |
    DIV_ASSIGN EXPRESIONES_LOGICAS {: syntaxError(((Symbol) stack.peek()), "Falta el identificador antes de '/='."); :} |
    ASSIGN EXPRESIONES_LOGICAS {: syntaxError(((Symbol) stack.peek()), "Falta el identificador antes de '=' en asignación."); :} |
    EXPRESIONES_LOGICAS ASSIGN EXPRESIONES_LOGICAS {: syntaxError(((Symbol) stack.peek()), "Error antes de '=' en asignación."); :} |
    EXPRESIONES_LOGICAS DIV_ASSIGN EXPRESIONES_LOGICAS {: syntaxError(((Symbol) stack.peek()), "Error antes de '/=' en asignación."); :} |
    EXPRESIONES_LOGICAS TIMES_ASSIGN EXPRESIONES_LOGICAS {: syntaxError(((Symbol) stack.peek()), "Error antes de '*=' en asignación."); :} |
    EXPRESIONES_LOGICAS MINUS_ASSIGN EXPRESIONES_LOGICAS {: syntaxError(((Symbol) stack.peek()), "Error antes de '-=' en asignación."); :} |
    EXPRESIONES_LOGICAS PLUS_ASSIGN EXPRESIONES_LOGICAS {: syntaxError(((Symbol) stack.peek()), "Error antes de '+=' en asignación."); :} 
;